<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Setup of Interactive Proofs | Sanjana Das</title> <meta name="author" content="Sanjana Das"> <meta name="description" content="An informal description of how interactive proofs work and a few examples."> <meta name="keywords" content="math, mit, notes, combinatorics"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sanjanad1024.github.io/blog/2024/interactive-proofs/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> <link rel="stylesheet" href="/assets/css/math.css?49733965db5e8d92bd661d2cd59af5d9"> <link rel="stylesheet" href="/assets/css/showhide.css?2ae93211fac637d8b63a8ea647d9337d"> <link rel="stylesheet" href="/assets/css/notes.css?931adbc419343c0b3205989a55f982d7"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span>Sanjana </span>Das</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/notes/">Notes</a> </li> <li class="nav-item "> <a class="nav-link" href="/papers/">Papers</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Setup of Interactive Proofs</h1> <p class="post-meta">June 3, 2024</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/category/complexity"> <i class="fa-solid fa-tag fa-sm"></i> complexity,</a>   <a href="/blog/category/tcs"> <i class="fa-solid fa-tag fa-sm"></i> TCS</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In this post, I’ll give an informal description of what interactive proofs are, and a few simple examples. The content of this post is based on lectures from the classes 18.404 (the lecture from December 7) and 18.405 (the lecture from April 11) at MIT. (This post is primarily setup for a few future posts on some really cool things we can do with interactive proofs.)</p> <p>We’ll first set up <em>deterministic</em> interactive proofs (to illustrate the model in a simpler setting, and to motivate what follows — in particular, why we need randomness); and then we’ll extend the model to <em>randomized</em> interactive proofs (which are what we’re really interested in).</p> <h1 id="deterministic-interactive-proofs">Deterministic interactive proofs</h1> <p>Imagine we’ve got a <span class="vocab">prover</span>, who we think of as all-powerful, and a <span class="vocab">verifier</span>, who we think of as computationally bounded. (This means we want the verifier to run in polynomial time; we don’t care how long the prover takes to run.)</p> <p>Imagine we’ve got a statement $x$, and the prover wants to convince the verifier that $x$ is true. To do so, the prover looks at $x$ and sends the verifier some message $m_1$. And then the verifier looks at $x$ and $m_1$, and sends the prover some message $m_2$. And then the prover looks at $x$, $m_1$, and $m_2$, and sends the prover some message $m_3$. And so on — the prover and verifier keep on talking back and forth, and eventually the verifier decides to <em>accept</em> (meaning they believe the prover and agree $x$ is true) or <em>reject</em> (meaning they don’t believe the prover and think $x$ is false).</p> <center><img src="/assets/img/ipsat1.png" width="400" height="auto"></center> <p>Note that since the verifier is supposed to run in $\textsf{poly}(\lvert x\rvert)$ time, the number of messages and the length of each message should be $\textsf{poly}(\lvert x\rvert)$.</p> <div class="question"> What kinds of statements can the prover convince the verifier of? Or in other words, what kinds of problems can we 'solve' using such a proof system? </div> <p>To formalize this, we need to define what it means to solve a problem using such a proof system. Imagine we’ve got a decision problem, which we can think of as a function \(f \colon \{0, 1\}^\ast \to \{0, 1\}\) (where we encode the input $x$ as a bit-string, and $f(x)$ is $1$ if $x$ is a $\textsf{YES}$ instance to the decision problem and $0$ if $x$ is a $\textsf{NO}$ instance) — so here the statement the prover is trying to convince the verifier of is that $f(x) = 1$.</p> <p>What should it mean for an interactive proof to ‘solve’ $f$? When we talk about an interactive proof solving $f$, we’re going to say essentially that there is a <em>verifier</em> who can be convinced of true statements of the form $f(x) = 1$, but not false ones. So on one hand, whenever $f(x) = 1$, there should be a <span class="vocab">good prover</span> that successfully convinces the verifier that $f(x) = 1$ (because this is true). On the other hand, when $f(x) = 0$, no <span class="vocab">cheating prover</span> should be able to convince the verifier that $f(x) = 1$ (because this is false) — so no matter what the prover tries to do, the verifier should reject.</p> <div class="definition"> We say $f$ <span class="vocab">has a deterministic interactive proof</span> if there is a verifier such that: <ul> <li> <span class="vocab">(Correctness)</span> For each $x$ such that $f(x) = 1$, there exists a prover that makes the verifier accept. </li> <li> <span class="vocab">(Soundness)</span> For each $x$ such that $f(x) = 0$, there does <em>not</em> exist a prover that makes the verifier accept (i.e., <em>every</em> possible prover causes the verifier to reject). </li> </ul> </div> <p>In other words, true statements of the form $f(x) = 1$ should have good proofs (that the verifier accepts), and false statements should not.</p> <div class="definition"> We define $\textsf{DIP}$ as the class of decision problems which have a deterministic interactive proof. </div> <h2 id="an-example--textsfsat">An example — $\textsf{SAT}$</h2> <p>To illustrate this definition, here’s an example of a deterministic interactive proof for $\textsf{SAT}$ — the problem where we’re given a Boolean formula $\varphi$, and we want to figure out whether it’s satisfiable or not.</p> <div class="definition"> We define $\textsf{SAT}$ as the following decision problem: <ul> <li> <b>Input:</b> a Boolean formula $\varphi$ (in some collection of variables $x_1$, $\ldots$, $x_n$, and with the operations $\wedge$, $\vee$, and $\neg$, which denote $\textsf{AND}$, $\textsf{OR}$, and $\textsf{NOT}$). </li> <li> <b>Decide:</b> whether there exists a <span class="vocab">satisfying assignment</span> to $\varphi$ — i.e., an assignment of values $a_1$, $\ldots$, $a_n$ to the variables (with $a_i \in \{\texttt{T}, \texttt{F}\}$ for each $i$) such that plugging them in makes $\varphi$ evaluate to $\texttt{T}$. </li> </ul> </div> <p>(In the notation where we think of decision problems as functions \(\{0, 1\}^\ast \to \{0, 1\}\), we’d say that $\textsf{SAT}(\varphi)$ is $1$ if $\varphi$ is satisfiable and $0$ if not; we think of $\varphi$ as being encoded as a bit-string in some reasonable way.)</p> <div class="example"> The problem $\textsf{SAT}$ has a deterministic interactive proof, where the verifier and good prover (for $\textsf{YES}$ instances) are defined as follows. On input $\varphi$: <ul> <li> The good prover finds a satisfying assignment to $\varphi$ and sends it to the verifier. </li> <li> The verifier plugs the assignment it receives into $\varphi$ and checks that it really is a satisfying assignment (and <span class="vocab">accepts</span> if yes and <span class="vocab">rejects</span> if no). </li> </ul> </div> <p>Note that we don’t need to care how long it takes the <em>prover</em> to come up with the satisfying assignment; what’s important is that the <em>verifier</em> can check that it’s really a satisfying assignment in polynomial time.</p> <p>This protocol satisfies correctness — if $\varphi$ is satisfiable, then the good prover will make the verifier accept. It also satisfies soundness — if $\varphi$ is <em>not</em> satisfiable, then no matter what assignment the cheating prover sends, when the verifier plugs it in, they’ll find that it’s not a satisfying assignment (because <em>no</em> assignment is), and so they’ll reject.</p> <h2 id="textsfdip--textsfnp">$\textsf{DIP} = \textsf{NP}$</h2> <p>Note that the protocol we gave for $\textsf{SAT}$ doesn’t involve any interaction at all — the prover just sends one message, and the verifier just looks at it and decides to accept or reject. In fact, this type of protocol corresponds exactly to the class $\textsf{NP}$. To see this, one way of defining $\textsf{NP}$ is as the class of problems with <span class="vocab">efficiently verifiable certificates</span>.</p> <div class="definition"> We define $\textsf{NP}$ as the class of decision problems $f$ such that there exists a polynomial-time algorithm $\mathcal{V}$ such that for all $x$, we have \[f(x) = 1 \iff (\exists \, y \text{ of length } \textsf{poly}(\lvert x\rvert))[\mathcal{V}(x, y) \text{ accepts}].\] </div> <p>In words, we think of $\mathcal{V}$ as a <span class="vocab">$\textsf{NP}$-verifier</span> for $f$ — it’s an efficient algorithm that takes in both our input $x$ and a polynomial-length <span class="vocab">certificate</span> $y$, and checks that $y$ is a ‘good certificate’ for $x$. And $\textsf{YES}$ instances $x$ should have good certificates (i.e., when $f(x) = 1$ there should exist a good certificate $y$), while $\textsf{NO}$ instances should <em>not</em> have good certificates.</p> <div class="example"> We have $\textsf{SAT} \in \textsf{NP}$ — we can define a 'good certificate' for $\varphi$ to be a satisfying assignment to $\varphi$ (we can construct a $\textsf{NP}$-verifier $\mathcal{V}$ which checks whether some assignment is a good certificate for $\varphi$ by simply plugging it in; and by definition $\varphi$ is a $\textsf{YES}$ instance to $\textsf{SAT}$ if and only if there exists a satisfying assignment, i.e., a good certificate for $\varphi$). </div> <p>In this definition, we can think of $\textsf{NP}$ as the class of problems $f$ which have a deterministic interactive proof with no interaction — the prover just sends a single message, and the verifier decides to accept or reject. (As in <span class="crossref">Example 5</span>, we define the good prover to send over a good certificate for the input $x$, and the verifier to check that the certificate it received really works — in particular, the verifier for the interactive proof is exactly the $\textsf{NP}$-verifier $\mathcal{V}$.) In particular, this immediately means $\textsf{NP} \subseteq \textsf{DIP}$ (as $\textsf{NP}$ is a special case of $\textsf{DIP}$).</p> <p>Our definition of deterministic interactive proofs allows for interaction, so we might hope that it makes the proof system more powerful. Unfortunately, this is false — it turns out that even <em>with</em> interaction, we can’t use such protocols to solve any problems other than the ones already in $\textsf{NP}$ (which we could have solved even without interaction).</p> <div class="theorem"> We have $\textsf{DIP} = \textsf{NP}$. </div> <div class="proof"> We've already seen that $\textsf{NP} \subseteq \textsf{DIP}$, so it remains to show that $\textsf{DIP} \subseteq \textsf{NP}$. Suppose $f \in \textsf{DIP}$, so we've got some deterministic interactive proof for $f$ — this means the prover and verifier talk back and forth, and eventually the verifier decides to accept or reject. Our goal is to remove the interaction from this protocol — i.e., to turn it into one where the prover sends a single message, and the verifier just decides whether to accept or reject. (This is because non-interactive deterministic interactive proofs correspond exactly to $\textsf{NP}$, as seen above.) <br><br> The idea is that because the verifier is deterministic, given the input $x$, the prover can know exactly what the entire interaction will look like — they know they're going to send a message $m_1$; then they can look at $x$ and $m_1$ and figure out exactly what message $m_2$ the verifier is going to send; then they can look at $x$, $m_1$, and $m_2$ and figure out exactly what message $m_3$ they'd respond with; and so on. <br><br> And this means the prover can just send the verifier their <em>entire</em> end of the interaction all in one message — i.e., the prover sends the verifier $(m_1, m_3, \ldots)$. And the verifier then simulates the interaction by themselves, plugging in these messages for the prover's end of the interaction — they look at $x$, imagine that the prover sends them $m_1$ and figure out what message $m_2$ they'd respond with, imagine that the prover then sends them $m_3$ and figure out what message $m_4$ they'd respond with, and so on; and in the end, they see whether they'd accept or reject (and they make the same decision here). <br><br> If $f(x) = 1$, then there's some good prover for the original protocol that makes the original verifier accept; so if we take $(m_1, m_3, \ldots)$ to correspond to that good prover, then the new verifier will accept as well (since it's just simulating the original verifier's interaction with that good prover). Meanwhile, if $f(x) = 0$, then every cheating prover for the original protocol makes the original verifier reject, so no matter what list of messages $(m_1, m_3, \ldots)$ the new cheating prover sends, the new verifier will reject as well (since it'll be simulating the original verifier's interaction with some cheating prover). </div> <h1 id="randomized-interactive-proofs">Randomized interactive proofs</h1> <p>We’ve seen that with deterministic interactive proofs, we don’t get anything out of interaction — in other words, any deterministic interactive proof that involves interaction can be turned into one that doesn’t (which means $\textsf{DIP} = \textsf{NP}$). And the reason for this was essentially that if the verifier is deterministic, then the prover can predict in advance <em>everything</em> that the verifier is going to say, so they can just have all their responses ready and send them all at once.</p> <p>We don’t like this — our hope is to define a reasonable model of interactive proofs that <em>increases</em> the class of problems we could solve. And the way we’re going to do this is by allowing the verifier to be <em>randomized</em> — this means the verifier gets to toss some coins when it’s choosing its message. So the prover looks at the input $x$ and sends a message $m_1$, as before. And then the verifier looks at $x$ and $m_1$ <em>and tosses some coins</em> to come up with a message $m_2$ to respond with. And then the prover looks at $x$, $m_1$, and $m_2$ to come up with a message $m_3$, and the verifier looks at $x$, $m_1$, $m_2$, and $m_3$ and tosses some more coins to come up with a message $m_4$, and so on; and in the end the verifier either accepts or rejects.</p> <center><img src="/assets/img/ipsat2.png" width="400" height="auto"></center> <p>(In this picture, $r_i$ denotes the randomness the verifier uses at each step — i.e., the outcomes of the $i$th set of coin tosses.)</p> <div class="remark"> We're using a <span class="vocab">private-coin model</span>, where the prover doesn't get to see the outcomes of the verifier's coin tosses. But you could also imagine a <span class="vocab">public-coin model</span>, where the prover <em>does</em> get to see these outcomes. Of course, any public-coin interactive proof can be made into a private-coin one (where we have the verifier simply announce the outcomes of their coin tosses together with the corresponding message). Quite surprisingly, it turns out that the converse is true as well — any private-coin protocol can also be made into a public-coin one! This is a very nice <a href="https://www.cs.toronto.edu/tss/files/papers/goldwasser-Sipser.pdf" target="_blank" rel="external nofollow noopener">result</a> of Goldwasser and Sipser (1986). <br><br> I'm probably not going to write more about the public-coin model; the protocol for graph non-isomorphism we'll see in this post will rely quite crucially on the fact that the prover doesn't see the verifier's coins (it can be converted to a public-coin protocol by the result of Goldwasser–Sipser, but this isn't obvious); but the protocols we'll see in future posts won't be (i.e., they can directly be viewed as public-coin protocols as well). </div> <p>We now need to define what it means for a randomized interactive proof to solve a decision problem $f$. This will be very similar to the definition for deterministic interactive proofs, but now that we’ve got randomness, we need to allow some probability of error (otherwise the randomness wouldn’t have any point).</p> <div class="definition"> We say $f$ <span class="vocab">has an interactive proof</span> if there is a verifier such that: <ul> <li> <span class="vocab">(Correctness)</span> For each $x$ such that $f(x) = 1$, there exists a prover that makes the verifier accept with probability at least $\frac{2}{3}$. </li> <li> <span class="vocab">(Soundness)</span> For each $x$ such that $f(x) = 0$, for every possible prover, the probability that the verifier accepts is at most $\frac{1}{3}$. </li> </ul> </div> <p>There’s a few decisions we’ve made with these definitions that aren’t obvious (i.e., it’d have been reasonable to do the opposite) but turn out not to matter:</p> <ul> <li> The values of $\frac{2}{3}$ (which we call the <span class="vocab">correctness parameter</span>) and $\frac{1}{3}$ (the <span class="vocab">soundness parameter</span>) are arbitrary — if we've got a protocol with these parameters, then we can get one with correctness parameter $1 - \frac{1}{2^k}$ and soundness parameter $\frac{1}{2^k}$ by simply running $\textsf{poly}(k)$ independent trials of the original one (and taking their majority outcome). </li> <li> We're allowing error in both the cases $f(x) = 0$ and $f(x) = 1$. But we could imagine instead allowing error in only one of the cases — we say a protocol has <span class="vocab">perfect correctness</span> if it only has error in the case $f(x) = 0$ (i.e., when $f(x) = 1$, there's a prover that makes the verifier <em>always</em> accept). <br><br> It turns out that any interactive proof protocol can be converted to one with perfect correctness; this is not obvious and is also a very nice result, though I'm not sure who it's due to. All the protocols we'll discuss will have perfect correctness. <br><br> (On the other hand, the error in soundness <em>is</em> necessary — it's <em>not</em> true that we can convert any protocol to one with perfect soundness.) </li> <li> We've made the <em>verifier</em> randomized, but we're still keeping the <em>prover</em> deterministic. We could imagine allowing the prover to be randomized as well, but this wouldn't increase the power of the system — the prover is computationally unbounded, so we can without loss of generality assume that the prover always (deterministically) chooses the response that maximizes the probability of the verifier accepting. </li> </ul> <h2 id="an-example--graph-non-isomorphism">An example — graph non-isomorphism</h2> <p>We first considered the model of <em>deterministic</em> interactive proofs, and we saw that the only problems we can solve using them are the problems in $\textsf{NP}$ (for which we don’t even need the interaction). So the first thing we might wonder is, does this new model of <em>randomized</em> interactive proofs, have the same issue, or does it actually allow us to solve new problems?</p> <p>So the first thing we’ll see is an example of an interactive proof for a problem that we don’t know to be in $\textsf{NP}$ — the problem of determining whether two graphs are <em>non</em>-isomorphic.</p> <div class="definition"> Two graphs $G_1$ and $G_2$ are <span class="vocab">isomorphic</span> if there's a way to permute the vertices of $G_1$ that turns it into $G_2$ — i.e., a permutation $\pi \colon V(G_1) \to V(G_2)$ such that $\{u, v\}$ is an edge in $G_1$ if and only if $\{\pi(u), \pi(v)\}$ is an edge in $G_2$. </div> <div class="definition"> We define $\textsf{GNI}$ as the following decision problem: <ul> <li> <b>Input:</b> two graphs $G_1$ and $G_2$ (with the same number of vertices). </li> <li> <b>Decide:</b> whether $G_1$ and $G_2$ are <em>non</em>-isomorphic. </li> </ul> </div> <p>Written as a function \(\{0, 1\}^\ast \to \{0, 1\}\), we’d say that $\textsf{GNI}(G_1, G_2)$ is $1$ if $G_1$ and $G_2$ are non-isomorphic, and $0$ if they are isomorphic.</p> <p>The opposite problem $\textsf{GI}$, of determining whether two given graphs $G_1$ and $G_2$ <em>are</em> isomorphic, is in $\textsf{NP}$ — we can take the certificate to simply be the permutation $\pi \colon V(G_1) \to V(G_2)$ that turns $G_1$ into $G_2$. This in particular means $\textsf{GI}$ has an interactive proof (that doesn’t involve any interaction), as with all problems in $\textsf{NP}$.</p> <p>But it <em>isn’t</em> clear whether $\textsf{GNI}$ is in $\textsf{NP}$ — there’s a simple certificate showing that two graphs <em>are</em> isomorphic, but we don’t know of a certificate showing that they’re <em>not</em> isomorphic.</p> <p>Still, it turns out that $\textsf{GNI}$ <em>does</em> have a (randomized) interactive proof!</p> <div class="example"> The problem $\textsf{GNI}$ has an interactive proof — on input $(G_1, G_2)$: <ul> <li> The verifier chooses $i \in \{1, 2\}$ uniformly at random and permutes the vertices of $G_i$ uniformly at random to produce a new graph $H$. </li> <li> The verifier sends the prover $H$ and asks them which of $G_1$ and $G_2$ it came from (i.e., what the value of $i$ is). They <span class="vocab">accept</span> if the prover answers correctly and <span class="vocab">reject</span> if not. </li> </ul> </div> <div class="proof"> If $G_1$ and $G_2$ are indeed non-isomorphic, then there's a good prover who'll always be able to answer correctly — $H$ must be isomorphic to the graph $G_i$ that the verifier chose (by construction), and it can't be isomorphic to the other one (because if it were isomorphic to both, then $G_1$ and $G_2$ are isomorphic). So the prover can simply recover $i$ by checking which of $G_1$ and $G_2$ it's isomorphic to. <br><br> Meanwhile, if $G_1$ and $G_2$ are isomorphic, then the graph $H$ that the prover sees has nothing to do with $i$ (i.e., it has the same distribution whether $i$ is $1$ or $2$ — either way, it's a uniform random element of their isomorphism class). So no matter what the cheating prover tries to do, they're essentially being asked to predict a random coin toss with no useful information, which means they'll only have a $\frac{1}{2}$ chance of being correct. </div> <h2 id="the-class-textsfip">The class $\textsf{IP}$</h2> <p>The example of an interactive proof for $\textsf{GNI}$ shows that adding randomness to our model has done <em>something</em> nontrivial — it’s allowed us to solve at least one problem that we wouldn’t have known how to solve without it. So that’s good news; but now we’d like to get a better understanding of <em>how</em> much more we can now solve.</p> <div class="definition"> We define $\textsf{IP}$ as the class of decision problems $f$ which have an interactive proof. </div> <div class="question"> How powerful is $\textsf{IP}$? </div> <p>It turns out, quite surprisingly, that $\textsf{IP}$ is <em>extremely</em> powerful!</p> <div class="theorem" text="Shamir 1990"> We have $\textsf{IP} = \textsf{PSPACE}$. </div> <p>(The class $\textsf{PSPACE}$ is defined as the class of problems which can be solved in polynomial <em>space</em>.)</p> <p>This is quite amazing — for example, it means that there’s an interactive proof that a Boolean formula is <em>not</em> satisfiable (which is already quite non-obvious), as well as lots of problems that look much harder.</p> <p>One direction of <span class="crossref">Theorem 16</span>, that $\textsf{IP} \subseteq \textsf{PSPACE}$, isn’t too difficult — the idea is that if we start with some interactive proof for some decision problem $f$, then by carefully going through all possible messages the prover and verifier could send, we can calculate the probability that the ‘optimal prover’ makes the verifier accept; and we can do this only using polynomial space. Here are the details of this argument.</p> <div class="lemma"> We have $\textsf{IP} \subseteq \textsf{PSPACE}$. </div> <div class="proof"> Suppose that $f \in \textsf{IP}$, so it has some verifier as in the definition of $\textsf{IP}$. Then in order to decide $f$ on an input $x$, our goal is to calculate the maximum (over all possible provers) of the probability (over the verifier's internal randomness) that the verifier accepts — because we know this probability is at least $\frac{2}{3}$ if $f(x) = 1$ (by correctness) and at most $\frac{1}{3}$ if $f(x) = 0$ (by soundness). <br><br> To do so, suppose the protocol runs for $k$ rounds (where $k = \textsf{poly}(\lvert x\rvert)$). Then for each $0 \leq i \leq k$, we'll define $\textsf{Prob}_i(x, m_1, \ldots, m_i)$ as the maximum (over all possible provers) probability that the verifier accepts if we start up the protocol from the end of the $i$th round pretending that these messages have already occurred (i.e., we imagine that the prover has already sent $m_1$, the verifier has already responded with $m_2$, and so on up to $m_i$; and now we're starting the protocol up from the end of the $i$th round, and we want to think about how it continues). Then our goal is to compute $\textsf{Prob}_0(x)$. <br><br> We'll compute these quantities recursively — suppose we're trying to compute $\textsf{Prob}_{i - 1}(x, m_1, \ldots, m_{i - 1})$. Then we consider what happens on the $i$th round. If $i$ is odd, meaning that the prover speaks, then since we're trying to take a <em>maximum</em> over all possible provers (i.e., we want to consider the <em>best</em> possible message $m_i$ for the prover to send), we have \[\textsf{Prob}_{i - 1}(x, m_1, \ldots, m_{i - 1}) = \max_{m_i}\textsf{Prob}_i(x, m_1, \ldots, m_i).\] Meanwhile, if $i$ is even, meaning that the verifier speaks, then we want to consider the <em>distribution</em> (over the verifier's internal randomness) of the message $m_i$ it sends (given the previous messages), and compute the appropriate weighted average of the acceptance probabilities of the remainder of the protocol, so \[\textsf{Prob}_{i - 1}(x, m_1, \ldots, m_{i - 1}) = \sum_i \mathbb{P}[\text{verifier sends $m_i$}]\cdot \textsf{Prob}_{i - 1}(x, m_1, \ldots, m_i).\] This gives a recursion that we can compute in polynomial space — we start with $i = 0$, then iterate over all messages $m_1$ one at a time, then iterate over all messages $m_2$ one at a time (for each $m_1$), and so on. At every layer of the recursion, we essentially only need to store the current message $m_i$ we're trying, as well as our current computation for the maximum or sum (note that the quantities $\mathbb{P}[\text{verifier sends $m_i$}]$ can be computed in polynomial space as well, simply by iterating over all possible outcomes of the verifier's coin tosses one at a time and running the verifier with each). <br><br> So we can use this recursion to compute $\textsf{Prob}_0(x)$ in polynomial space, which lets us solve $f$. </div> <p>So the direction that $\textsf{IP} \subseteq \textsf{PSPACE}$ is not too hard. On the other hand, the direction that $\textsf{PSPACE} \subseteq \textsf{IP}$ — that every problem which can be solved in polynomial <em>space</em> in fact has an interactive proof where the verifier runs in polynomial <em>time</em> — is much more surprising, and the proof involves several very cool ideas. I’ll explain the proof in future posts.</p> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Sanjana Das. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with the <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="external nofollow noopener">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script type="text/javascript">window.MathJax={loader:{load:["[tex]/color"]},tex:{packages:["base","color","ams","amsmath"],inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,processRefs:!0,digits:/^(?:[0-9]+(?:\{,\}[0-9]{3})*(?:\.[0-9]*)?|\.[0-9]+)/,tags:"none",tagSide:"right",tagIndent:"0.8em",useLabelIds:!0,maxMacros:1e3,maxBuffer:5120,formatError:(a,e)=>a.formatError(e)},svg:{fontCache:"global"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script> <script>$(document).ready(function(){$(".sd-hidden").each(function(){console.log($(this).attr("desc"));let t=$(this).attr("desc")?$(this).attr("desc"):"Hidden";$(this).wrap("<span class='wrap-hidden'></span>"),$(this).parent().prepend(`<span class='hide-heading'>${t}</span>`),$(this).parent().find(".hide-heading").click(function(){console.log("btn2",$(this).text());let t=$(this).parent();console.log("par",t.text());let e=t.find(".sd-hidden");console.log("hidden",e.text()),e.toggle()})})});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>